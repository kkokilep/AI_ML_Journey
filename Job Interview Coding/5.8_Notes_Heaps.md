# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/29/2025) </u>

### Topic: Heap Properties
#### Notes: 

* Order a queue based on a priority
* Min / Max Priority
* Priority Queue implemented with a Binary Heap
* Min Heap more common

* Structure Property = Complete Binary Tree
  * Tree where every single level is completely full except for the last level
  * Need to add nodes from left to right
* Order Property = Want to find the minimum or maximum value really quickly
  * Recursively all values should be greater than or equal to the root for the total tree and all subtrees
  * Can have duplicates
* Want minimum or maximum at the root
* Implemented as arrays
  * Put root at index 1
  * Due to structure we can access all the children directly in an array
  * leftChild = 2*i
  * rightChild = 2*i+1
  * parent = i/2
  * Not true for a regular binary tree

### Topic: Heap Push and Pop
#### Notes:

* Add in an element as the child
* Swap the parent and child if the heap property isn't statisfied
* Since the parent was originally valid, there is no need to check the subtree connected on the other side


```aiignore
class Heap:
    def __init__(self):
        self.heap = [0]
    def push(self,val):
        self.heap.append(val)
        i = len(self.heap)-1
        while(self.heap[i] < self.heap[i//2]):
            tmp = self.heap[i]
            self.heap[i] = self.heap[i//2]
            self.heap[i//2] = tmp
            i = i // 2
```

* Insertion is O(log(n))

* Pop involves removing the root and replacing it with the last element in the heap
* Then swap constantly until it arrives at the last value in the heap.

```
def pop(self):
  if len(self.heap) == 1:
    return None
  if len(self.heap) == 2:
    return self.heap.pop()
  
  res = self.heap[1]
  self.heap[1] = self.heap.pop()
  i = 1
  while 2 * i < len(self.heap):
    if(2*i+1 < len(self.heap) and self.heap[2*i+1] < self.heap[2*i] and self.heap[i] > self.heap[2*i + 1]):
      tmp = self.heap[i]
      self.heap[i] = self.heap[2*i+1]
      self.heap[2*i+1] = tmp
      i = 2*i + 1

    elif self.heap[i] > self.heap[2*i]:
      tmp = self.heap[i]
      self.heap[i] = self.heap[2*i]
      self.heap[2*i] = tmp
      i = 2 * i
    else:
      break
  return res
```

### Topic: Heapify
#### Notes:

* Heapify takes a set of values and converts them into a heap
* Most of the nodes won't have children so we can skip them at start of algorithm.
* Go through every node that has children and percolate down if it can move down.


```
def heapify(self, arr):
  arr.append(arr[0])
  self.heap = arr
  cur = (len(self.heap) - 1) // 2
  while cur > 0:
    i = cur
    while 2 * i < len(self.heap):
      if(2*i+1 < len(self.heap) and self.heap[2*i+1] < self.heap[2*i] and self.heap[i] > self.heap[2*i + 1]):
        tmp = self.heap[i]
        self.heap[i] = self.heap[2*i+1]
        self.heap[2*i+1] = tmp
        i = 2*i + 1

      elif self.heap[i] > self.heap[2*i]:
        tmp = self.heap[i]
        self.heap[i] = self.heap[2*i]
        self.heap[2*i] = tmp
        i = 2 * i
      else:
        break
    cur = cur - 1
```