# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Dynamic Programming 1D
#### Notes: 

```aiignore
def bruteforce(n):
    if n<=1:
        return n
    return bruteforce(n-1) + bruteforce(n-2)
```
* Idea is to remove a certain amount of repeated work

```aiignore
def memoization(n,cache):
    if n<=1:
        return n
    if n in cache:
        return cache[n]
    cache[n] = memoization(n-1) + memoization(n-2)
    return cache[n]

print(memoization(5,{}))
```
* Idea is to store previous values in a cache that prevents having to have extra calls to a cache storage.
* Reduces the operation to O(n)
* Known as top Down Dynamic Programming

```aiignore
def dp(n):
    if n < 2:
        return n
    dp = [0, 1]
    i = 2
    while i <=n:
        tmp = dp[1]
        dp[1] = dp[0] + dp[1]
        dp[0] = tmp
        i += 1
    return dp[1]
print(dp(10))
```
* Dynamic Programming Solution using Bottom Up Technique with O(n) Solution
* Need only save 2 previous values at a time
* Break down problem into solving sub problems and then saving the intermediate solutions


### Topic: Dynamic Programming 2D
#### Notes: 

* Count the number of unique paths from the top left to the bottom right. You are only allowed to move down or to the right.

```aiignore
def brute(r,c,rows,cols):
    if r == rows or c == cols:
        return 0
    if r == rows - 1 and c == cols - 1:
        return 1
    return (brute(r+1,c,rows,cols) + brute(r,c+1,rows,cols))
print(brute(0,0,4,4))

def memoization(r,c,rows,cols,cache):
    if r == rows or c == cols:
        return 0
        
    if cache[r][c] > 0:
        return cache[r][c]
    
    if r == rows -1 and c ==cols - 1:
        return 1
    
    cache[r][c] = (memoization(r+1,c,rows,cols,cache) + memoization(r,c+1,rows,cols,cache))
   
    return cache[r][c]
print(memoization(0,0,4,4,[[0] * 4 for i in range(4)]))
```
* O(n*m) for memoization
* O(2^{n+m}) for Brute Force

```aiignore
def dp(rows,cols):
    prevRow = [0] * cols
    for r in range(rows-1,-1,-1):
        curRow = [0] * cols
        curRow[cols-1] = 1
        for c in range(cols-2,-1,-1):
            curRow[c] = curRow[c+1] + prevRow[c]
        prevRow = curRow
    return prevRow[0]
print(dp(4,4))
```
* Time: O(n*m) and Space is O(m) where m is the number of columns