# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (10/01/2025) </u>

### Topic: 0/1 Knapsnack
#### Notes: 

* Given a list of N items, and a backpack with a limited capacity, return the maximum profit that can be contained in the backpack.
* The ith item's profit is profit[i] and its weight is weight[i]. Assume you can only add each item to the bag at most one time.

* Start with brute force to understand the problem
* C = 8
* Binary Decision Tree of size 2^n

* O(2^n) time complexity
* Space O(n)
```aiignore
def dfs(profit, weight, capacity):
    return dfsHelper(0, profit, weight, capacity)
 
 def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    maxProfit = dfsHelper(i + 1, profit, weight, capacity)
    
    newCap = capacity - weight[i]
    if newCap >= 0:
        p = profit[i] + dfsHelper(i+1,profit,weight,newCap)
        maxProfit = max(maxProfit, p)
    return maxProfit
```

* Can optimize to O(n*m) time complexity
* n * m
* Large decision trees imply the existence of duplicate work

```
def memoization(profit, weight, capacity):
    N, M = len(profit), capacity
    cache = [[-1] * M + 1 for _ in range(N)]
    return dfsHelper(0, profit, weight, capacity)
 
 def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    if cache[i][capacity] != -1:
        return cache[i][capacity]
    
    cache[i][capacity] = memoHelper(i+1,profit,weight,capacity,cache)
    
    
    newCap = capacity - weight[i]
    if newCap >= 0:
        p = profit[i] + memoHelper(i+1,profit,weight,capacity,cache)
        cache[i][capacity] = max(cache[i][capacity], p)
    return cache[i][capacity]
```

* True Dynamic Programming Solution can optimize the space complexity
* No Recursion needed and use a 2D array instead
* 4 rows and number of columns for the capacity.

* Each index represents the max profit with a corresponding item

```aiignore
def dp(profit, weight, capacity):
    N,M = len(profit), capacity
    dp = [[0] * (M+1) for _ in range(N)]
    
    for i in range(N):
        dp[i][0] = 0
    
    for c in range(M+1):
        if weight[0] <= c:
            dp[0][c] = profit[0]
            
    for i in range(1,N):
        for c in range(1,M+1):
            skip = dp[i-1][c]
            include = 0
            if c - weight[i] >=0:
                include = profit[i] + dp[i-1][c-weight[i]]
            dp[i][c] = max(include,skip)
    return dp[N-1][M] 
```


### Topic: Unbounded Knapsnack
#### Notes: 

* Given a list of N items, and a backpack with a limited capacity, return the maximum total profit that can be contained in the backpack. 
* The ith item's profit is profit[i] and the weight is weight[i]. Assume unlimited amount of each item available.
* O(2^C) in the worst case

```aiignore
def dfs(profit, weight, capacity):
    return dfsHelper(0, profit, weight, capacity)

def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    
    maxProfit = dfsHelper(i+1, profit, weight, capacity)
    
    newCap = capacity - weight[0]
    if newCap >= 0:
        p = profit[i] + dfsHelper(i, profit, weight, newCap)
        maxProfit = max(maxProfit, p)
    
    return maxProfit
```

```aiignore
def memoization(profit,weight,capacity):
    N,M = len(profit), capacity
    cache = [[-1] * (M + 1) for _ in range(N)]
    return memoHelper(0, profit, weight, capacity, cache)

def memoHelper(i, profit, weight, capacity, cache):
    if i == len(profit):
        return 0
    
    if cache[i][capacity] != -1:
        return cache[i][capacity]
    
    
    cache[i][capacity] = memoHelper(i+1, profit, weight, capacity, cache)
    
    newCap = capacity - weight[i]
    
    if newCap >= 0:
        p = profit[i] + memoHelper(i, profit, weight, newCap, cache)
        
        cache[i][capacity] = max(cache[i][capacity], p)
    
    return cache[i][capacity] 
```

```aiignore
def dp(profit, weight, capacity):
    N,M = len(profit), capacity
    dp = [[0] * (M+1) for _ in range(N)]
    
    for i in range(N):
        dp[i][0] = 0
    
    for c in range(M+1):
        if weight[0] <= c:
            dp[0][c] = profit[0]
            
    for i in range(1,N):
        for c in range(1,M+1):
            skip = dp[i-1][c]
            include = 0
            if c - weight[i] >=0:
                include = profit[i] + dp[i][c-weight[i]]
            dp[i][c] = max(include,skip)
    return dp[N-1][M] 
```

```aiignore
def optimizedDP(profit,weight,capacity):
    N,M = len(profit), capacity
    dp = [0] * (M+1)
    for i in range(N):
        curRow = [0]*(M+1)
        for c in range(1,M+1):
            skip = dp[c]
            include = 0
            if c - weight[i] >= 0:
                include = profit[i] + curRow[c-weight[i]]
            curRow[c] = max(include,skip)
        dp = curRow
    return dp[M]
```

### Topic: Longest Common Subsequence
#### Notes: 

* Given two strings s1 and s2, find the length of the longest common subsequence between two strings
* Relative order must be maintained
* Idea is remove characters and have equal strings between both words

* Complexity of dfs solution is O(2^{n+m}), Space: O(n+m)
```aiignore
def dfs(s1,s2):
    return dfsHelper(s1,s2,0,0)

def dfsHelper(s1,s2,i1,i2):
    if i1 == len(s1) or i2 == len(s2):
        return 0
    
    if s1[i1] == s2[i2]:
        return 1 + dfsHelper(s1,s2,i1+1,i2+1)
    else:
        return max(dfsHelper(s1,s2,i1+1,i2), dfsHelper(s1,s2,i1,i2+1))
```

```aiignore
def memoization(s1,s2):
    N, M  = len(s1), len(s2)
    cache = [[-1]*M for _ in range(N)]
    
    return memoHelper(s1,s2,0,0,cache)

def memoHelper(s1,s2,i1,i2,cache):
    if i1 == len(s1) or i2 == len(s2):
        return 0
    if cache[i1][i2] != -1:
        return cache[i1][i2]
    
    if s1[i1] == s2[i2]:
        cache[i1][i2] = 1 + memoHelper(s1, s2, i1 + 1, i2 + 1, cache)
    else:
        cache[i1][i2] = max(memoHelper(s1,s2,i1+1,i2,cache), memoHelper(s1,s2,i1,i2+1,cache))
    return cache[i1][i2]
```
* Add extra dimension to avoid out of bounds
```aiignore
def dp(s1,s2):
    N,M = len(s1), len(s2)
    dp = [[0] * (M+1) for _ in range(N+1)]
    
    for i in range(N):
        for j in range(M):
            if s1[i] == s2[j]:
                dp[i+1][j+1] = 1 + dp[i][j]
            else:
                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])
    return dp[N][M]
```

### Topic: Palindrome
#### Notes: 

* Given a string S, return the length of the longest palindromic substring within S
* O(n^3) solution means apply palindrome algorithm for every single substring possible.

* Use two pointers to determine if it's a palindrome

* Start in the middle most character and expand outwards.

* if the characters are not equal
* Check every character for the longest palindromic substring
* In either one goes out of bounds, then we know that we have the largest substring possible.
* Can stop also when we reach not equal characters.
* Start with a base substring of size 2 to handle even cases.

```
def longest(s):
    length = 0
    for i in range(len(s)):
        l,r = i,i
        while l >= 0 and r < len(s) and s[l] == s[r]:
            if (r-l + 1) > length:
                length = r - 1 + 1
            l -= 1
            r += 1
        
        l,r = i,i+1
        while l >= 0 and r < len(s) and s[l] == s[r]:
           if (r-l + 1) > length:
                length = r - 1 + 1
            l -=1
            r +=1
    
    return length
```