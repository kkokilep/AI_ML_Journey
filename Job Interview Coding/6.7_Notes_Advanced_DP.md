# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (10/01/2025) </u>

### Topic: 0/1 Knapsnack
#### Notes: 

* Given a list of N items, and a backpack with a limited capacity, return the maximum profit that can be contained in the backpack.
* The ith item's profit is profit[i] and its weight is weight[i]. Assume you can only add each item to the bag at most one time.

* Start with brute force to understand the problem
* C = 8
* Binary Decision Tree of size 2^n

* O(2^n) time complexity
* Space O(n)
```aiignore
def dfs(profit, weight, capacity):
    return dfsHelper(0, profit, weight, capacity)
 
 def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    maxProfit = dfsHelper(i + 1, profit, weight, capacity)
    
    newCap = capacity - weight[i]
    if newCap >= 0:
        p = profit[i] + dfsHelper(i+1,profit,weight,newCap)
        maxProfit = max(maxProfit, p)
    return maxProfit
```

* Can optimize to O(n*m) time complexity
* n * m
* Large decision trees imply the existence of duplicate work

```
def memoization(profit, weight, capacity):
    N, M = len(profit), capacity
    cache = [[-1] * M + 1 for _ in range(N)]
    return dfsHelper(0, profit, weight, capacity)
 
 def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    if cache[i][capacity] != -1:
        return cache[i][capacity]
    
    cache[i][capacity] = memoHelper(i+1,profit,weight,capacity,cache)
    
    
    newCap = capacity - weight[i]
    if newCap >= 0:
        p = profit[i] + memoHelper(i+1,profit,weight,capacity,cache)
        cache[i][capacity] = max(cache[i][capacity], p)
    return cache[i][capacity]
```

* True Dynamic Programming Solution can optimize the space complexity
* No Recursion needed and use a 2D array instead
* 4 rows and number of columns for the capacity.

* Each index represents the max profit with a corresponding item

```aiignore
def dp(profit, weight, capacity):
    N,M = len(profit), capacity
    dp = [[0] * (M+1) for _ in range(N)]
    
    for i in range(N):
        dp[i][0] = 0
    
    for c in range(M+1):
        if weight[0] <= c:
            dp[0][c] = profit[0]
            
    for i in range(1,N):
        for c in range(1,M+1):
            skip = dp[i-1][c]
            include = 0
            if c - weight[i] >=0:
                include = profit[i] + dp[i-1][c-weight[i]]
            dp[i][c] = max(include,skip)
    return dp[N-1][M] 
```


### Topic: Unbounded Knapsnack
#### Notes: 

* Given a list of N items, and a backpack with a limited capacity, return the maximum total profit that can be contained in the backpack. 
* The ith item's profit is profit[i] and the weight is weight[i]. Assume unlimited amount of each item available.
* O(2^C) in the worst case

```aiignore
def dfs(profit, weight, capacity):
    return dfsHelper(0, profit, weight, capacity)

def dfsHelper(i, profit, weight, capacity):
    if i == len(profit):
        return 0
    
    maxProfit = dfsHelper(i+1, profit, weight, capacity)
    
    newCap = capacity - weight[0]
    if newCap >= 0:
        p = profit[i] + dfsHelper(i, profit, weight, newCap)
        maxProfit = max(maxProfit, p)
    
    return maxProfit
```

```aiignore
def memoization(profit,weight,capacity):
    N,M = len(profit), capacity
    cache = [[-1] * (M + 1) for _ in range(N)]
    return memoHelper(0, profit, weight, capacity, cache)

def memoHelper(i, profit, weight, capacity, cache):
    if i == len(profit):
        return 0
    
    if cache[i][capacity] != -1:
        return cache[i][capacity]
    
    
    cache[i][capacity] = memoHelper(i+1, profit, weight, capacity, cache)
    
    newCap = capacity - weight[i]
    
    if newCap >= 0:
        p = profit[i] + memoHelper(i, profit, weight, newCap, cache)
        
        cache[i][capacity] = max(cache[i][capacity], p)
    
    return cache[i][capacity] 
```

```aiignore
def dp(profit, weight, capacity):
    N,M = len(profit), capacity
    dp = [[0] * (M+1) for _ in range(N)]
    
    for i in range(N):
        dp[i][0] = 0
    
    for c in range(M+1):
        if weight[0] <= c:
            dp[0][c] = profit[0]
            
    for i in range(1,N):
        for c in range(1,M+1):
            skip = dp[i-1][c]
            include = 0
            if c - weight[i] >=0:
                include = profit[i] + dp[i][c-weight[i]]
            dp[i][c] = max(include,skip)
    return dp[N-1][M] 
```

```aiignore
def optimizedDP(profit,weight,capacity):
    N,M = len(profit), capacity
    dp = [0] * (M+1)
    for i in range(N):
        curRow = [0]*(M+1)
        for c in range(1,M+1):
            skip = dp[c]
            include = 0
            if c - weight[i] >= 0:
                include = profit[i] + curRow[c-weight[i]]
            curRow[c] = max(include,skip)
        dp = curRow
    return dp[M]
```

### Topic: Longest Common Subsequence
#### Notes: 

* Given two strings s1 and s2, find the length of the longest common subsequence between two strings
* Relative order must be maintained
* Idea is remove characters and have equal strings between both words

