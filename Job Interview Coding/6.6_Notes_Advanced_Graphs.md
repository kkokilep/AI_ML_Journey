# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (10/01/2025) </u>

### Topic: Dijkstra's Shortest Path
#### Notes: 

* BFS only works when the edges are not weighted
* Starting from one node, find the length of the shortest path to every other node

* Perform greedy BFS
* Idea is to visit the path with the lesser weight
* Assumption is no negative weights
* Set cost of initial node as 0
* Add total cost from the reference node
* Fill the graph with the shortest path
* Visit the nodes that
* Use a minHeap with a pair of values (cost, node)
* Use adjacency list to represent graph
* Use the cost to push to the heap
* Pop the node with the smallest cost and then
* Size of heap can end up being the number of edges
* log(E) operation for pushing and popping from heap.
* O(Elog(E))

```
def shortestPath(edges,n, src):
    adj = {}
    for i in range(1,n+1):
        adj[i] = []
    for s,d,w ub edges:
        adj[s].append((d,w))

    shortest = {}
    minHeap = [(0,src)]
    while minHeapL
        w1, n1 = heapq.heappop(minHeap)
        if n1 in sortest:
            shortest[n1] = w1
        
        for n2,w2 in adj[n1]:
            if n2 not in shortest:
                heapq.heappush(minHeap, (w1 + w2,n2))
        
    return shortest
```

### Topic: Prim's (Minimum Spanning Tree)
#### Notes: 

* Undirected Graph
* Connected graph has a path to every node

* Tree must be acyclical without cycles
* Given a graph find a subset of edges that form a tree while minimizing the total cost of the edges

