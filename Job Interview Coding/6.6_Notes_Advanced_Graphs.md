# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (10/01/2025) </u>

### Topic: Dijkstra's Shortest Path
#### Notes: 

* BFS only works when the edges are not weighted
* Starting from one node, find the length of the shortest path to every other node

* Perform greedy BFS
* Idea is to visit the path with the lesser weight
* Assumption is no negative weights
* Set cost of initial node as 0
* Add total cost from the reference node
* Fill the graph with the shortest path
* Visit the nodes that
* Use a minHeap with a pair of values (cost, node)
* Use adjacency list to represent graph
* Use the cost to push to the heap
* Pop the node with the smallest cost and then
* Size of heap can end up being the number of edges
* log(E) operation for pushing and popping from heap.
* O(Elog(E))

```
def shortestPath(edges,n, src):
    adj = {}
    for i in range(1,n+1):
        adj[i] = []
    for s,d,w ub edges:
        adj[s].append((d,w))

    shortest = {}
    minHeap = [(0,src)]
    while minHeapL
        w1, n1 = heapq.heappop(minHeap)
        if n1 in sortest:
            shortest[n1] = w1
        
        for n2,w2 in adj[n1]:
            if n2 not in shortest:
                heapq.heappush(minHeap, (w1 + w2,n2))
        
    return shortest
```

### Topic: Prim's (Minimum Spanning Tree)
#### Notes: 

* Undirected Graph
* Connected graph has a path to every node

* Tree must be acyclical without cycles
* Given a graph find a subset of edges that form a tree while minimizing the total cost of the edges

* Tree of N nodes needs N-1 edges


* Return list of edges of minimum spanning a tree

* Use a visited hash set and a MinHeap of the weights of the edges

* Follows similarly to Dijkstra's algorithm

* Elog(E) time complexity : Elog(V)
* O(E)


```
def minimumSpanningTree(edges, n):
    adj = {}
    for i in range(1,n+1):
        adj[i] = []
    for src, dst, weight in edges:
        adj[src].append((dst,weight))
        adj[dst].append((src,weight))
    
    minHeap = []
    for neighbor, weight in adj[1]:
        heapq.heappush(minHeap,(weight,1,neighbor))
    
    mst = []
    visit = set()
    visit.add(1)
    while minHeap:
        weight, src, node = heapq.heappop(minHeap)
        if node in visit:
            continue
        mst.append([src,node])
        visit.add(node)
        for neighbor, weight in adj[node]:
            if neighbor not in visit:
                heapq.heappush(minHeap, [weight,node,neighbor])

    return mst

```

### Topic: Kruskal's (Minimum Spanning Tree)
#### Notes: 

* Uses Union Find Data Structure
* As we add edges then consider the nodes as members as an entire union
* Make sure we don't introduce an edges that creates a cycle

def minimumSpanningTree(edges,n):
    minHeap = []
    for n1, n2, weight in edges:
        heapq.heappush(minHeap,[weight,n1,n2])
    
    unionFind = UnionFind(n)
    mst = []
    while len(mst) < n -1:
        weight, n1, n2 = heapq.heappop(minHeap)
        if not unionFind.union(n1,n2)
            continue
        mst.append([n1,n2])
    
    return mst


### Topic: Topological Sort
#### Notes: 

* Topological sort many of them
* A valid topological ordering means every edge should have a direction.
* Source node comes before the desitnation node
* No requirement on which nodes comes first amonst the sibling
* Works for directed graphs that are acyclicalgraph
* DAG
* Graphs don't need to be connected

```aiignore
def topologicalSort(edges, n):
    adj = {}
    for i in range(1, n+ 1):
        adj[i] = {}
    for src, dst in edges:
        adj[src].append(dst)
    
    topSort = []
    visit = set()
    
    for i in range(1,n+1):
        dfs(i, adj, visit, topSort)
    topSort.reverse()
    return topSort

def dfs(src, adj, visit, topSort):
    if src in visit:
        return True
    
    visit.add(src)
    
    for neighbor in adj[src]:
        dfs(neighbor, adj, visit, topSort)
    
    topSort.append(src)
```

* Can also add a second hash set to do cycle detection called path
* Can also check if the source has been added to the path