# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Kadane's Algorithm
#### Notes: 

* Find a non-empty subarray with the largest sum
* Subarray is a contiguous subarray
* Brute Force is go through all sub arrays and compute the sum in every single case
  * O(n * m)

```aiignore
def bruteForce(nums):
    maxSum = nums[0]
    for i in range(len(nums)):
        curSum = 0
        for j in range(i,len(nums)):
            curSum += nums[j]
            maxSum = max(maxSum, curSum)
    return maxSum
```

```aiignore
def kadanes(num):
    maxSum = nums[0]
    curSum = 0
    for n in nums:
        curSum = max(curSum,0)
        curSum += n
        maxSum = max(maxSum, curSum)
    return maxSum
```
* O(n) complexity

* Return the left and right index of the max subarray sum
```
def slidingWindow(nums):
    maxSum = nums[0]
    curSum = 0
    maxL, maxR = 0,0
    L = 0
    
    for R in range(len(nums)):
        if curSum < 0:
            curSum = 0
            L - R
        curSum += nums[R]
        
        if curSum > maxSum:
            maxSum = curSum
            maxL, maxR = L, R
    return [maxL, maxR]
```

### Topic: Sliding Window Fixed Size
#### Notes: 

* Given an array, return true if there are two elements within a window of size k that are equal

```aiignore
def closeDuplicatesBruteForce(nums,k):
    for L in range(len(nums)):
        for R in range(L+1,min(len(nums),L+k)):
            if nums[L] == nums[R]:
                return True
    return False
```
* Complexity of O(n*k)
* Can use Hash Set to optimize

```aiignore
def closeDuplicates(nums, k):
    window = set()
    L = 0
    for R in range(len(nums)):
        if R - L + 1 > k
            window.remove(nums[L])
            L += 1
        if nums[R] in window:
            return True
        window.add(nums[R])
    return False
```

### Topic: Sliding Window Variable Size
#### Notes: 

* Find the length of the longest subarray with the same value at each position
* Find the longest string of duplicates

```aiignore
def longestSubArray(nums):
    length = 0
    L = 0
    for R in range(len(nums)):
        if nums[L] != nums[R]:
            L = R
        length = max(length, R-L + 1)
    return length
```
* O(n) time complexity


* Given array of all positive integers, find the minimum length subarray where the sum is greater than or equal to the target.


```aiignore
def shortestSubArray(nums,target):
    total, L = 0, 0
    length = float('inf')
    
    for R in range(len(nums)):
        total += nums[R]
        while total >= targetL
            length = min(R-L + 1, length)
            total-=nums[L]
            L +=1
    return 0 if length == float('inf') else length
```
* O(n) linear time complexity algorithm

### Topic: Two Pointers
#### Notes: 

* Check if an array is a palindrome
* 2 pointers care about the two individual elements that the pointers are pointing at

```aiignore
def isPalindrome(word):
    L, R = 0, len(word) - 1
    while L < R:
        if word[L] != word[R]
            return False
        L = L + 1
        R = R - 1
    return True
```

* Given a sorted input array, return the two indices of two elements which sum up to the target value.
* Assume there's exactly one solution

```aiignore
def targetSum(nums, target):
    L,R = 0, len(nums) - 1
    
    while L < R:
        if nums[L] + nums[R] > target:
             R -= 1
        elif nums[L] + nums[R] < target:
            L += 1
        else:
            return [L, R]
```
* O(n) time complexity

### Topic: Prefix Sums
#### Notes: 

* Contiguous sub array that starts at the beginning of a sub array
* Prefix sum is a sum of the starting elements

* Given an array of values, design a data structure that can query the sum of a subarray of values.
  * Naive solution is O(n)
* Can acquire the prefix sum in O(1) time
```aiignore
class PrefixSum:
    def __init__(self,nums):
        self.prefix = []
        total = 0
        for n in nums:
            total+=n
            self.prefix.append(total)
        
    def rangeSum(self, left, right):
        preRight = self.prefix[right]
        preLeft = self.prefix[left-1] if left > 0 else 0
        return preRight - preLeft
```