# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Subsets
#### Notes: 

* Given a list of distinct nums, return all possible distinct subsets
* Every value can be included in a subset or not included
* Result is a decision tree

* Result is that all the children will respresent distinct subsets
* Empty set is a distinct subset that we want to return
* Result is 2^n where n is the number of input values

* Result is a nested array where each is built separately
* Result is O(n*2^n) in time complexity
* Space complexity O(n)

```
def subsetWithoutDuplicates(nums):
    subsets, curSet = [], []
    helper(0,nums,curSet,subsets)
    return subsets


def helper(i,nums, curSet,subsets):
    if i >= len(nums):
        subsets.append(curSet.copy())
        return
    
    curSet.append(nums[i])
    helper(i+1, nums,curSet,subsets)
    curSet.pop()

    helper(i+1,nums,curSet,subsets)
```

* Given a list of nums not distinct, but we want to return all distinct subsets.

* Start by sorting which is less important due to exponential cost of this problem
* Since it's sorted, can tell all duplicates are near each other

* Skip everything and go to the next value
* Then in the path that includes the value have it only contain a single 2

```
def subsetsWithDuplicates(nums):
    nums.sort()
    subsets, curSet =[], []
    helper2(0,nums, curSet, subsets)
    return subsets

def helper2(i,nums, curSet,subsets):
    if i >= len(nums):
        subsets.append(curSet.copy())
    
    curSet.append(nums[i])
    helper2(i+1, nums, curSet,subsets)
    curSet.pop()

    while i+1 < len(nums) and nums[i] == nums[i+1]:
        i+=1
    helper2(i+1, nums, curSet, subsets)
```


### Topic: Combinations
#### Notes: 

* Given two nums n and k, return all possible combinations of size = k, chooseing from values between 1 and n 
* Similar to subset solution with a different time complexity
* 2^n = Size of the tree itself
* O(k * 2^n)
* O(k * X)
* Less combinations than there are subsets
* C(n,k) = n! / (k! (n-k!))

```
def combinations(n, k):
    combs = []
    helper(1, [],combs, n, k)

def helper(i, curComb, combs, n, k):
    if len(curComb) == k:
        combs.append(curComb.copy())
        return
    
    if i > n:
        return
    
    curComb.append(i)
    helper(i+1,curComb,combs,n,k)
    curComb.pop()
    helper(i+1, curComb, combs, n, k)
```

*O(k * C(n,k))
```
def combinations2(n,k):
    combs = []
    helper2(1,[],combs,n,k)
    return combs

def helper2(i, curComb, combs, n, k):
    if len(curComb) == k:
        combs.append(curComb.copy())
        return
    
    if i > n:
        return
    
    for j in range(i,n+1):
        curComb.append(j)
        helper(j+1, curComb, combs, n, k)
        curComb.pop()
```


### Topic: Permutations
#### Notes: 

* Given a list of numbers, return all possible distinct permutations of nums.

* In this case, the order matters.

* Number of possible permutations is n!
* Can use the basic tree approach
* Instead generate all possible permutations with the other numbers

* Idea is to insert at every possible positions for the iterative solution

```
def permutationsRecursive(nums):
    return helper(0,nums)

def helper(i, nums):
    if i == len(nums):
        return [[]]
    resPerms = []
    perms = helper(i+1,nums)
    for p in perms:
        for j in range(len(p) + 1):
            pCopy = p.copy()
            pCopy.insert(j, nums[i])
            resPerms.append(pCopy)
    return resPerms
```

```
def permutationsIterative(nums):
    perms = [[]]
    for n in nums:
        nextPerms = []
        for p in perms:
            for i in range(len(p) + 1):
                pCopy = p.copy()
                pCopy.insert(i,n)
                nextPerms.append(pCopy)

        perms = nextPerms

    return perms
```
* insert(index, value) command  for lists
* O(n^2 * n!)