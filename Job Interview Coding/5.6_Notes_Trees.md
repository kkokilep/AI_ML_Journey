# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/29/2025) </u>

### Topic: Binary Tree
#### Notes: 

* Structures as Nodes with certain values
* Left and right pointer
* Parent and child relationship
* Nodes without any children are called leaf nodes
* The top node is the root node
* No cycles in a binary tree
* Sibling nodes have the same parent
* Height is the number of levels that exist underneath a node
* Descendant is any child or any other node that comes beneath it
* Ancestor is a node that came before a specific node
* Depth is the length of path that leads back to the root node.

```aiignore
class TreeNode:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
```


### Topic: Binary Search Tree
#### Notes:

* Sorted Property
* Every single node in left subtree has to be less than the root value
* Every single node in right subtree has to be greater than the root value
* Binary search trees do not contain duplicates
* The sorting property must be true for every single node in the tree and its corresponding subtrees.
* Gives a search time of O(log(n))
* Needs tree to be roughly balanced to get this time complexity
* Imbalanced tree could approach O(n)

```aiignore
def search(root,target):
    if not root:
        return False
    if(target > root.val):
        return search(root.right,target)
    elif(target < root.val):
        return search(root.left,target)
    else:
        return True
```


### Topic: Binary Search Tree Insert and Remove
#### Notes:

* insert(root,6)
* Easier to insert a node as a leaf node
* Traversing the tree in the same way as binary search
* O(log(n)) for a balanced tree

```aiignore

def insert(root,val):
    if not root:
        return TreeNode(val)
    if val > root.val:
        root.right = insert(root.right,val)
    elif val < root.val:
        root.left = insert(root.left,val)
    return root
```

* Find the minimum of a tree = Furthest node to the left

```aiignore
def minValueNode(root):
    curr = root
    while curr and curr.left:
        curr = curr.left
    return curr
```

* Case 1: 0 or 1 Child
  * Need to set left or right to Null
  * Check if left or right pointer is Null
  * Return the child that exists so that the ancestor points at the child of removed node
* Case 2: 2 children
  * Find the node
  * Check if two children
  * Replace the node with one of its children
  * Recursively call the remove on the subtree that is removed.
  * Complication is that the BST property must be maintained.
    * Want to choose a leaf node that represents the smallest value in the right subtree or the largest value in the left subtree.
* Need to find the node to remove with a binary search

```aiignore
def remove(root,val):
    if not root:
        return None
    if val > root.val:
        root.right = remove(root.right,val)
    elif val < root.val:
        root.left = remove(root.left,val)
    else:
        if not root.left:
            return root.right
        elif not root.right:
            return root.left
        else:
            minNode = minValueNode(root.right)
            root.val = minNode.val
            root.right = remove(root.right,minNode.val)
    return root
```
* Traverse 2*log(n)
* O(log(n))

### Topic: DFS
#### Notes:

* inorder traversal = Go through the values in order
* Left, current node, and then right

```aiignore
def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.val)
    inorder(root.right)
```

* O(n) to traverse
* O(nlogn) to build the tree
* preorder = Visit the root, print whole left subtree, print whole right subtree

```aiignore
def preorder(root):
    if not root:
        return
    print(root.val)
    preorder(root.left)
    preorder(root.right)
```

```aiignore
def postorder(root):
    if not root:
        return
    preorder(root.left)
    preorder(root.right)
    print(root.val)
```
* Post order = visit the left, visit the right, and then get back to the root


### Topic: BFS
#### Notes:

```aiignore
from collections import deque

def bfs(root):
    queue = deque()
    if root:
        queue.append(root)
    level = 0
    while len(queue) > 0:
        for i in range(len(queue)):
            curr = queue.popleft()
            
            if(curr.left):
                queue.append(curr.left)
            if(curr.right):
                queue.append(cur.right)
        level+=1
```
* O(n) complexity
* Traverse Level by Level

### Topic: Sets and Maps
#### Notes:

* Sets and Maps
* Set is a data structure that stores a collection of unique elements and does not allow duplicate values
* Sets can be implemented as BST
* Mapping one data type to some other related source of data
  * Key Value Pairing
  * Sory by Key and keep value associated

```aiignore
from sortedcontainers import SortedDict
treeMap = SortedDict({'c':3,'a':1,'b':2})
```