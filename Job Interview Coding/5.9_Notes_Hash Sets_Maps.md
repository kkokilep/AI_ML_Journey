# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Hash Usage
#### Notes: 

* Key in a map is used to sort a BST
* Insert is O(1)
* Remove is O(1)
* Search is O(1)
* Tree maps are O(log(n)) for all these operations
* Hash maps have no sense of ordering
* Requires a sorting algorithm of O(nlog(n))
* Duplicates are not allowed in hash maps
```aiignore
countMap = {}
for name in names:
    if name not in countMap:
        countMap[name] = 1
    else:
        countMap[name] +=1
```

### Topic: Hash Implementation
#### Notes: 

* Implemented with an array 
  * Index is associated with a key, value pair
* Need hashing function that converts key value into a corresponding index
* Can modulate the generated value by the size of the array to get a valid index
* Can get the locations back after hashing with the same function
* Problem with hashing is the existence of a collision
  * Minimize collisions by resizing the array after the hash is half full
  * Need to move the values to new locations after resizing the array
    * Need to recompute the hash with the new size
    * Called rehashing the array which doesn't happen that often
    * Can also use open addressing to move it to the next available space.
      * Don't have to search through the entire index, just need to arrive at an empty location.
* Can do other math operations to do open addressing.
* Size of array being a prime number reduces the number of collisions.

```aiignore
class Pair:
    def __init__(self,key,val):
        self.key = key
        self.val = val
class HashMap:
    def __init__(self):
        self.size = 0
        self.capacity = 2
        self.map = [None, None]
    def hash(self,key):
        index = 0
        for c in key:
            index += ord(c)
        return index % self.capacity
    def get(self,key):
        index = self.hash(key)
        while self.map[index] !=None:
            if self.map[index].key == key:
                return self.map[index].val
            index+=1
            index = index % self.capacity
        return None
    
    def put(self,key,val):
        index = self.hash(key)
        
        while True:
            if self.map[index] == None:
                self.map[index] = Pair(key,val)
                self.size+=1
                if self.size >= self.capacity // 2:
                    self.rehash()
                return
            
            elif self.map[index].key == key:
                self.map[index].val = val
                return
            
            index = index + 1
            index = index % self.capacity
    def rehash(self):
        self.capacity = 2 * self.capacity
        newMap = []
        for i in range(self.capacity):
            newMap.append(None)
        
        oldMap = self.map
        self.map = newMap
        self.size = 0
        
        for pair in oldMap:
            if pair:
                self.put(pair.key,pair.val)
    
```