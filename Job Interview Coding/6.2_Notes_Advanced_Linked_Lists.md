# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Fast and Slow Pointers
#### Notes: 

* Find the middle of a linked List
* O(n) fast and slow pointer algorithm
* Initialize fast and slow at the head
* Shift Fast pointer by 2 spaces
* Slow pointer shift by 1 space'
* Repeat until one reaches the end of the list
* Slow pointer should be at the middle of the list

```aiignore
def middleOfList(head):
    slow,fast = head,head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```

* Determine if linked list has a cycle
* Initialize both at head
* Increment fast by 2 and slow by 1
* Pointers will intersect and we know that there is a cycle
* Slow pointer will only need to go through once with O(n)

```aiignore
def hasCycle(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
            
    return False
```

* Determine if a linked list has a cycle and return the head of the cycle
* Create a second slow pointer set to beginning of the list
* Stop using the fast pointer
* Increment the second slow pointer
* Two pointers are guaranteed to intersect at the start of the cycle.

```aiignore
def cycleStart(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    if not fast or not fast.next"
        return None
    slow2 = head
    while slow != slow2:
        slow = slow.next
        slow2 = slow2.next
    return slow
```
* P = Head to Cycle Start Distance
* C = Length of Cycle
* X = Length of cycle excluding the distance from the stary of cycle to the intersection point
* 2* slow = Fast
* 2 * (P +C - X) = P + C + C - X
* P - X = 0