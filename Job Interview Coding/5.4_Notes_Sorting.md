# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/29/2025) </u>

### Topic: Insertion Sort
#### Notes: 

* Sort values one by one until you have the entire array sorted
* Should not move to the next element until you know that the subarray is sorted.
  * Don't need to compare with all elements of the array because we know that the previous sub array is sorted
* If you arrive at a value that is bigger than last element of previous sub array, then continually swap until you reach an element that you are larger than.
* Need check in bounds first before making comparison to avoid out of bounds error.

```aiignore
for i in range(1,len(arr)):
    j=i-1
    while(j>=0 and arr[j+1] < arr[j]):
        tmp = arr[j+1]
        arr[j+1] = arr[j]
        arr[j] = tmp
        j = j - 1
```

* Stable vs. Unstable Sorting algorithm
  * Preserves the relative sorting of elements
* For an already sorted array, then it is O(n) time complexity.
* Worst case time complexity O(n^2) (half the size of n^2 and remove the constant)

### Topic: Merge Sort
#### Notes: 

* Split input into equal halves iteratively until you have individual elements to sort
* Sort first half of the values and the second half of the values
* Idea is to use recursion to solve
* Can merge individual sorted arrays back into original array that is sorted
  * This makes the sub array sorted
* Then move onto the right half of the array and sort this set.
* Use 2 pointer technique to fill in the higher order array
  * Third pointer in output array to identify which element we are at the higher pointer array.
  * Once you run out of elements in one sub array then fill rest from the original array.

* Merge sort runs in O(nlog(n)) = log(n) is number of levels of recursion. n is number of steps per level to do merge operation.
* Stable = Preserves order of elements in a tie
* Can control the merging process in order to ensure stability of the operation.
```aiignore
def mergeSort(arr,s,e):
    if(e-s+1<=1):
        return arr
    m = (s+e)/2
    mergeSort(arr,s,m)
    mergeSort(arr,m+1,e)
    merge(arr,s,m,e)
    
    return arr
```

### Topic: Quick Sort
#### Notes: 

* Pick rightmost(random) value and set it as the pivot value.
* Compare every other value with the pivot value.
* Add all elements less than pivot to the left half.
* Add all elements greater than pivot to the right half.
* 1 pointer is the location in the array.
* Second pointer looks at where we move an element in the case that it's less than the pivot.
  * We then shift until we find another element less than the pivot and swap with the other pointer.
* Once reach the pivot index, we can stop and swap the pivot with the left pointer.
* Results in every element on the left tree being less than that of the right side.
* Pivot point on left half is already sorted.
* Repeat Quick Sort on these sub halves that are created.
* Do the split based on where the pivot was inserted.

* Quick Sort does not add space memory since every operation involves swapping.
* Results in final base case providing a sorted array.
* Way you select the pivot effects whether you reach the worst possible case.
* Number of levels is log(n)
* nlog(n) is average and the worst case is O(n^2)
* QuickSort is not stable generally due to the swapping procedure

```aiignore
def quickSort(arr,s,e):
    if(e-s+1<=1):
        return arr
    pivot = arr[e]
    left = s
    for i in range(s,e):
        if(arr[i] < pivot):
            tmp = arr[left]
            arr[left] = arr[i]
            arr[i] = tmp
            left += 1
    arr[e] = arr[left] 
    arr[left] = pivot
    
    quickSort(arr,s,left-1)
    quickSort(arr,left+1,e)
    
    return arr  
```

### Topic: Bucket Sort
#### Notes: 

* Rare to use Bucket Sort
* Need all the values to fit in a finite range
* Create a bucket for every single value.
* Create counts for every single element.
* Counting is O(n)
* Can then place all the values in the array in the correct order
* 