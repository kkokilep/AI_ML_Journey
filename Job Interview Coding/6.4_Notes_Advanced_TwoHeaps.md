# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Two Heaps
#### Notes: 

* Finding the median is one application
* Provided a stream of values over time and find the median

* Implement a median finder where new values are inserted into the set and you have to getMedian from that set

* Idea is to have a small heap with smaller values and implemented as a max Heap and a large heap implemented as a minHeap
* Insert into the small heap
* Take lengths and take average of the root of each heap in the case that the lengths are the same
* If the lengths are different, then maintain it as 1. 
* Need to move between heaps in order to maintain balance between the heaps.
* Move all numbers into the small heap and then move them over if they are not.
* Median is in the larger heap


```
class Median:
    def __init__(self):
        self.small, self.large = [], []
    
    def insert(self, num):
        heapq.heappush(self.small,-1*num)

        if(self.small and self.large and (-1 * self.small[0]) > self.large[0]):
            val = -1 * heapq.heappop(self.small)
            heapq.heappush(self.large,val)

        if len(self.small) > len(self.large) + 1:
            val = -1*heapq.heappop(self.small)
            heapq.heappush(self.large,val)
        if len(self.large) > self.small + 1:
            val = heapq.heappop(self.large)
            heapq.heappush(self.small,-1*val)

    def getMedian(self):
        if len(self.small) > len(self.large):
            return -1 * self.small[0]
        elif len(self.large) > len(self.small):
            return self.large[0]
        

        return (-1 * self.small[0] + self.large[0]) / 2

```

