# General Notes


These notes are taken from the Data Structures Beginners Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Graphs
#### Notes: 

* Graph made of nodes and pointers that connect them together
  * Vertices are nodes
  * Edges are pointers to connect the nodes together.
  * Graphs are different from trees due to the ability to have different cycles
* Edges <= Vertices ^ 2
* Directed Graph = Pointers go in a specific direction
  * Trees and Linked Lists are examples of directed graphs
* Undirected graph can go in either direction between nodes
* Represent a graph with a matrix or an adjacency List

* Matrix represented as a 2D Array, where each element is its own array.
  * Use rows, columns to represent a matrix
  * grid[1] = 1D array
  * grid[1,0] = element
  * Can use as graph by represent each 0 as a free space and 1 as a blocked location
  * Every element of graph with a free space is a node.
  * Edges are the corresponding adjacencies between cells.
* adjMatrix[v1][v2] = 1 (An Edge exists from v1 to v2)
  * Dimension represents the nodes
  * A 1 or 0 indicates the existence of an edge between specific nodes
  * Provides a means of specifying a directed edge.
  * Order in which you index indicates the direction of the edge
  * Space complexity is O(v^2).
* Adjacency List
  * Use a generic list at every node to indicate the connections.
  * Make an array of GraphNodes
    * Use the value parameter to identify the node.

```aiignore
class GraphNode:
    def __init__(self,val):
        self.val = val
        self.neighbors = []
```


### Topic: Matrix DFS
#### Notes: 

* Count unique paths from the top left to the bottom right. A single path may only move along 0's and can't visit same cell more than once.


```aiignore
def dfs(grid,r,c,visit):
    ROWS, COLS = len(grid), len(grid[0])
    # Check out of bounds
    # Check out of bounds by reaching max columns or ROWS
    # Don't use a combination that already exists in visited locations
    # Don't reach a blocked position
    # Hash Set data structure for visit
    if(min(r,c) < 0 or r == ROWS or c == COLS or (r,c) in visit or grid[r][c] == 1):
        return 0
    # Return 1 count if you reach the end of the destination
    if r == ROWS - 1 and c == COLS - 1:
        return 1
    
    # Add locations to the visit set
    visit.add((r,c))
    
    # From this position how many ways can we get to the end
    count = 0
    count +=dfs(grid,r=1,c,visit)
    count +=dfs(grid,r-1,c,visit)
    count +=dfs(grid,r,c+1,visit)
    count +=dfs(grid,r,c-1,visit)
    # Backtracking to return back to a location that did not try every location
    visit.remove((r,c))
    return count
print(dfs(grid,0,0,set()))
```

* Worst case is that any given path is the size of the matrix.
  * Time complexity is 4^{N*M} where 4 is the number of possible branching positions
* O(n*m) is memory complexity in order to keep the call stacks stored

### Topic: Matrix BFS
#### Notes: 

* Find the length of the shortest path from the top left to the grid to the bottom right
* Time complexity is O(n*m)

```aiignore

def bfs(grid):
    ROWS, COLS = len(grid), len(grid[0])
    
    # Visit hash set
    visit = set()
    # Need queue to tell us the current level that we are at.
    queue = deque()
    queue.append((0,0))
    visit.add((0,0))
    length = 0
    while queue:
        for i in range(len(queue)):
            r,c = queue.popleft()
            # return length if we are at the destination
            if r == ROWS - 1 and c == COLS - 1:
                return length
            # Keep track of the neighbors that we can explore in.
            neighbors = [[0,1],[0,-1],[1,0],[-1,0]]
            for df, dc in neighbors:
            if (min(r+dr, c+dc) < 0 or r+dr ==ROWS or c+dc ==COLS or (r+dr, c+dc) in visit or grid[r+dr][c+dc] == 1):
                continue
            queue.append((r+dr, c+dc))
            visit.add((r+dr, c+dc))
        length +=1
        
print(bfs(grid))
```


### Topic: Adjacency List
#### Notes: 

```aiignore
class GraphNode:
    def __init__(self, val):
        self.val = val
        self.neighbors = []
    
adjList = {'A':[],'B':[]}

adjList = {}
edges = [["A","B"],["B","C"],["B","E"]]

for src,dst in edges:
    if src not in adjList:
        adjList[src] = []
    if dst not in adjList:
        adjList[dst] = []
    adjList[src].append(dst)
```

* Shortest path from a node to a target

```aiignore

def dfs(node,taret,adjList,visit):
    if node in visit:
        return 0
    if node == target:
        return 1
    count = 0
    visit.add(node)
    for neighbor in adjList[node]:
        count += dsf(neighbor, target, adjList,visit)
    visit.remove(node)
    
    return count

print(dfs("A","E",adjList,set()))
```
* O(N^V) is the time complexity for dfs on adjacency list where N is the average number of leaving points

```aiignore
def bfs(node,target,adjList):
    length = 0
    visit = set()
    visit.add(node)
    queue = deque()
    queue.append(node)
    
    while queue:
        for i in range(0,len(queue)):
            curr = queue.popleft()
            if curr == target:
                return length
            
            for neighbor in adjList[curr]:
                if neighbor not in visit:
                    visit.add(neighbor)
                    queue.append(neighor)
        length +=1
    return length

print(bfs("A","E",adjList))
        
```

* O(v ^ 2) this is the total number of vertices and number of edges follows inequality law.
* O(V + E)
* Memory compleixty is O(V)
* Did not consider the case with weights