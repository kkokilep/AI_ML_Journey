# General Notes


These notes are taken from the Adavanced Algorithms Course on Neetcode io.

# <u> Date (09/30/2025) </u>

### Topic: Trie
#### Notes: 

* Also called a Prefix Tree
* Insert word in constant time
* Search word in constant time
* Search prefix in constant time
* Trie is a tree of characters
* Only need to worry about lower case characters
* Every character has 26 children to represent all the other children
```aiignore
class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = False
class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self,word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                curr.children[c] = TrieNode()
            curr = curr.children[c]
        curr.word = True
        
    def search(self, word):
        curr = self.root
        for c in word:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return curr.word
    
    def startsWith(self, prefix):
        curr = self.root
        for c in prefix:
            if c not in curr.children:
                return False
            curr = curr.children[c]
        return True
```
* Insert means iterate through every character and add it as a TrieNode
* Search means iterate through all the characters in the trie
* Don't want redundant characters
* Can get a prefix


### Topic: Union-Find
#### Notes: 

* Tree Data Structure applied to generate graphs
* Graph is not fully connected
* DFS can accomplish in same time complexity

* Given list of edges [1,2], [4,1], [2,4] and given 4 nodes
* Idea is to create a valid graph based on nodes and edges
* Balancing union makes it more efficient to traverse
* Union by Rank (height)
* Use the height to perform the union
* Can only union if they are not already connected
* Indicate that the graph has a cycle


```
class UnionFind:
    def __init__(self,n):
        self.par = {}
        self.rank = {}

        for i in range(1,n+1):
            self.par[i] = i
            self.rank[i] = 0
    def find(self,n):
        p = self.par[p]
        while p != self.par[p]:
            self.par[p] = self.par[self.par[p]]
            p = self.par[p]
        return p 

    def union(self,n1,n2):
        p1, p2 = self.find(n1), self.find(n2)
        if p1 == p2:
            return False

        if self.rank[p1] > self.rank[p2]:
            self.par[p2] = p1
        elif self.rank[p2] > self.rank[p1]:
            self.par[p1] = p2
        else:
            self.par[p1] = p2
            self.rank[p2] += 1
        
        return True
```
* O(1) for union operation
* O(log(n)) for finding
* Inverse ackerman function with rank and path compression that leads to a constant
* O(m) for number of edges.

### Topic: Segment Tree
#### Notes: 

* update(index, val)
* queryRange(L,R)
* Given an array of values
    * Want to be able to update the index with a specific value
    * Want to query within a specific range of values such as a sum of values
    * Can update and query in log(n) time
* Takes segments of an array
* Root node represents entire array
* Every node represents portions of the array
    * Can't update a single value, need to update the children with the value
    * Find the midpoint value of the indices
    * Then use that to assign left and right boundaries for the children.
    * Break up sections until you have individual array elements
    * Want to assign the sum of the range
    * Can get the queries from the left and right children

```
class SegmentTree:
    def __init__(self,total,L,R):
        self.sum = total
        self.left = None
        self.right = None
        self.L = L
        self.R = R
    
    # O(n)
    @staticmethod
    def build(nums,L,R):
        if L == R:
            return SegmentTree(nums[L],L,R)
        
        M = (L+R) // 2
        root = SegmentTree(0,L,R)
        root.left = SegmentTree.build(nums,L,M)
        root.right = SegmentTree.build(nums, M+1,R)
        root.sum = root.left.sum + root.right.sum
        return root
    
    def update(self, index, val):
        if self.L == self.R:
            self.sum = val
            return
        M = (self.L + self.R) // 2
        if index > M:
            self.right.update(index,val)
        else:
            self.left.update(index,val)
        self.sum = self.left.sum + self.right.sum

    def rangeQuery(self,L,R):
        if L == self.L and R == self.R:
            return self.sum
        M = (self.L + self.R) // 2

        if L > M:
            return self.right.rangeQuery(L,R)
        elif R <=M:
            return self.left.rangeQuery(L,R)
        else:
            return (self.left.rangeQuery(L,M) + self.right.rangeQuery(M+1,R))
```
* Heaps are full binary trees
* Regular heaps would be filled from left to right
* Implemented with Arrays possibly
* log(n)

### Topic: Iterative DFS
#### Notes: 

* Inorder = print left, print root, print right
* Explicitly declare a stack and save nodes inside of it

* Time and Space O(n)
```
class TreeNode:
    def __init__(self, val, left, right):
        self.val = val
        self.right = right
        self.left = left
    
def inorder(root):
    stack = []
    curr = root

    while curr or stack:
        if curr:
            stack.append(curr)
            curr = curr.left
        else:
            curr =stack.pop()
            print(curr.val)
            curr = curr.right

```

* Preorder = root, left subtree, right subtree
* Process current node before any of the children

```
def preorder(root):
    stack = []
    curr = root
    while curr or stack:
        if curr:
            print(curr.val)
            if curr.right:
                stack.append(curr.right)
            curr = curr.left
        else:
            curr =stack.pop()
```

* Post-order uses two stacks
* Process left, right, root

```
def postorder(root):
    stack = [root]
    visit = [False]
    while stack:
        curr, visited = stack.pop(), visit.pop()
        if curr:
            if visited:
                print(curr.val)
            else:
                stack.append(curr)
                visit.append(True)
                stack.append(curr.right)
                visit.append(False)
                stack.append(curr.left)
                visit.append(False)
```